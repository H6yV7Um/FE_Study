# MVC和类

## 一、什么是 MVC

MVC 是一种设计模式，它将应用划分为 3 个部分 :数据(模型)、展现层(视图)和用
户交互层(控制器)。换句话说，一个事件的发生是这样的过程 :

1. 用户和应用产生交互。
2. 控制器的事件处理器被触发。
3. 控制器从模型中请求数据，并将其交给视图。
4. 视图将数据呈现给用户。

### 1.1 模型

模型用来存放应用的所有数据对象。比如，可能有一个 User 模型，用以存放用户列表、 他们的属性及所有与模型有关的逻辑。

模型不必知晓视图和控制器的细节，模型只需包含数据及直接和这些数据相关的逻辑。 任何事件处理代码、视图模板，以及那些和模型无关的逻辑都应当隔离在模型之外。将模型和视图的代码混在一起，是违反 MVC 架构原则的。模型是最应该从你的应用中解耦出来的部分。

当控制器从服务器抓取数据或创建新的记录时，它就将数据包装成模型实例。也就是说，我们的数据是面向对象的(object oriented)，任何定义在这个数据模型上的函数或逻辑 都可以直接被调用。

因此，不要这样做 :

```js
var user = users["foo"];
destroyUser(user);
```

而要这样做 :

```js
var user = User.find("foo");
user.destroy();
```

第 1 段代码没有命名空间的概念，并且不是面向对象的。如果在应用中定义了另一个destoryUser() 函数的话，两个函数就会产生冲突。我们应当确保全局变量和函数的个数尽可能少。在第 2 段代码中，destory()函数是存放在命名空间 User 的实例中的，User 中存放了所有的记录。当然这只是理想状况，因为我们控制了全局变量的个数，更好地避免了潜在的冲突，这种代码更加清晰，而且非常容易做继承，类似 destory() 的这种函数就不用在每个模型中都定义一遍了。

### 1.2 视图

视图层是呈现给用户的，用户与之产生交互。在 JavaScript 应用中，视图大都是由 HTML、CSS 和 JavaScript 模板组成的。除了模板中简单的条件语句之外，视图不应当 包含任何其他逻辑。

实际上，和模型类似，视图也应当从应用的其他部分中解耦出来。视图不必知晓模型和 控制器中的细节，它们是相互独立的。将逻辑混入视图之中是编程的大忌。

这并不是说 MVC 不允许包含视觉呈现相关的逻辑，只要这部分逻辑没有定义在视图之 内即可。我们将视觉呈现逻辑归类为“视图助手”(helper):和视图有关的独立的小型工具函数。

来看下面的例子，视图中包含了逻辑，这是一个反例，平时不应当这样做 :

```js
// template.html 
<div>
	<script>
		function formatDate(date) {
			/* ... */ 
		};
	</script>
	${ formatDate(this.date) } 
</div>
```

在这段代码中，我们把 formatDate() 函数直接插入视图中，这违反了 MVC 的原则，结 果导致标签看上去像大杂烩一样不可维护。可以将视觉呈现逻辑剥离出来放入视图助手 中，正如下面的代码就避免了这个问题，可以让这个应用的结构满足 MVC。

```js
// helper.js
var helper = {};
helper.formatDate = function(){ /* ... */ };

// template.html 
<div>
	${ helper.formatDate(this.date) }
</div>
```

此外，所有视觉呈现逻辑都包含在 helper 变量中，这是一个命名空间，可以防止冲突并保持代码清晰、可扩展。

### 1.3 控制器

控制器是模型和视图之间的纽带。控制器从视图获得事件和输入，对它们进行处理(很 可能包含模型)，并相应地更新视图。当页面加载时，控制器会给视图添加事件监听，比 如监听表单提交或按钮点击。然后，当用户和你的应用产生交互时，控制器中的事件触 发器就开始工作了。

不用使用类库和框架也能实现控制器，下面这个例子就是使用简单的 jQuery 代码来实现 的:

```js
var Controller = {};
// 使用匿名函数来封装一个作用域 
(Controller.users = function($){
	var nameClick = function(){ /* ... */ };
	// 在页面加载时绑定事件监听 
	$(function(){
		$("#view .name").click(nameClick);
	});
})(jQuery);
```

我们创建了 users 控制器，这个控制器是放在 Controller 变量下的命名空间。然后，我 们使用了一个匿名函数封装了一个作用域，以避免对全局作用域造成污染。当页面加载时，程序给视图元素绑定了点击事件的监听。

正如你所看到的，控制器并不依赖类库或框架。然而，为了构建需要的一个完整的 MVC 框架，我们需要将模型从视图中抽离出来。

## 二、向模块化进军，创建类

对于静态的类来说，JavaScript 对象直接量就已经够用了，但使用继承和实例来创建经典的类往往更有帮助。有必要强调一下 :JavaScript 是基于原型的编程语言，并没有包含内置类的实现。但通过 JavaScript 可以轻易地模拟出经典的类。

JavaScript 中并没有真正的类，但 JavaScript 中有构造函数和 new 运算符。构造函数用来给实例对象初始化属性和值。任何 JavaScript 函数都可以用做构造函数，构造函数必须使用 new 运算符作为前缀来创建新的实例。

new 运算符改变了函数的执行上下文，同时改变了return语句的行为。实际上，使用 new 和构造函数和传统的实现了类的语言中的使用方法是很类似的 :

```js
var Person = function(name) { 
	this.name = name;
};
// 实例化一个Person
var alice = new Person('alice');
// 检查这个实例
assert( alice instanceof Person );
```

构造函数的命名通常使用驼峰命名法，首字母大写，以此和普通的函数区分开来，这是一种习惯用法。记住这一点非常重要，因为你不会希望用省略 new 前缀的方式来调用构造函数。

```js
// 不要这么做!
Person('bob'); //=> undefined
```

这个函数只会返回 undefined，并且执行上下文是 window(全局)对象，你无意间创建了一个全局变量 name。调用构造函数时不要丢掉 new 关键字。

当使用 new 关键字来调用构造函数时，执行上下文从全局对象(window)变成一个空的上下文，这个上下文代表了新生成的实例。因此，this 关键字指向当前创建的实例。尽管理解起来有些绕，实际上其他语言内置类机制的实现也是如此。

默认情况下，如果你的构造函数中没有返回任何内容，就会返回this——当前的上下文。 要不然就返回任意非原始类型的值。比如，我们可以返回一个用以新建一个新类的函数， 第一步要做的是创建自己的类模拟库 :

```js
var Class = function(){ 
	var klass = function(){
		this.init.apply(this, arguments); 
	};
	klass.prototype.init = function(){};
	return klass; 
};

var Person = new Class;

Person.prototype.init = function(){ 
	// 基于Person的实例做初始化
};

// 用法 :
var person = new Person;
```

## 三、给类添加函数

在 JavaScript 中，在构造函数中给类添加函数和给对象添加属性是一模一样的 :
























