# 适配器模式 Adapter

## 一、概述

适配器模式的作用是解决两个对象间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个对象可以一起工作。

举个例子：香港的插头和国内的插口不一样。如果从香港买了一个电器，我们会发现充电器无法插在家里的插座上，为此而改造家里的插座显然不方便，所以我们需要一个转换插头。

**何时使用**： 

- 1、系统需要使用现有的类，而此类的接口不符合系统的需要
- 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。
- 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

**优点**：

-  1、可以让任何两个没有关联的类一起运行。
-  2、提高了类的复用。
-  3、增加了类的透明度。
-  4、灵活性好。

**缺点**：过多地使用适配器，会让系统非常混乱，不容易整体进行把控。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，就会是一场灾难难以维护。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。

## 二、运用

通过上述例子，我们可以知道适配器模式有三个角色：

- 目标角色（Target）：国内的电器插头
- 源角色（Adaptee）: 香港的电器插头
- 适配器角色（Adapter）: 把香港的电器插头转成更小国内的电器插头，来适配国内的插座

目标角色实现

```js
class Target {
    small(){
        throw new Error('此方法必须重写');
    }
}
```

由Target接口实现目标角色，用户期待更小的电器插头。

源角色实现

```js
class Adaptee {
    big(){
        console.log("已经帮你转成可用的");
    }
}
```

Adaptee 属于更大的港式的电器插头，这和用户所期望的不同。所以这里需要引入适配器，去转换成用户所期待的目标接口。

适配器实现

```js
class Adapter extends Target {
    constructor(adaptee) {
        super();
        this.adaptee = adaptee;
    }
    small() {
        this.adaptee.big();
    }
}
```

Adapter 类继承了 Target，重写 small 函数，最后通过适配器，把港式big转成了大陆的small了。

test:

```js
let adaptee=new Adaptee();
let adapter=new Adapter(adaptee);
adapter.small();
# 已经帮你转成可用的
```





















