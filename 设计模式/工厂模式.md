# 工厂模式 Factory

## 一、简单工厂模式

### 1.1 概述

简单工厂模式：简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一。它定义一个工厂类，它可以根据参数的不同返回不同的实例，被创建的实例通常都具有共同的父类。

简单工厂模式在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计。简单来说，就是我传一个参数（男、女、人妖）进去，可以创建对应性别的人出来。

### 1.2 运用

简单工厂模式的角色：

- Product（抽象产品类）：一般是一个抽象类或是接口
- ConcreteProduct（具体产品类）：实现或是继承 Product
- Factory（工厂类）：用来创建具体的产品

场景描述：我去商店买菜，结果老板跟我说，你要什么自己去拿吧(工厂类Factory)，那也就是，我想要什么这个动作，就是我们传参数进去来得到某个东西。

Product类

```js
// 抽象食物类
class Foods {
	describe(){
		throw new Error("此方法必须复写")
	}
}
```

ConcreteProduct类

```js
class Meat extends Foods {
	describe(){
		throw new Error("我是肉")
	}
}

class Vegetables extends Foods {
	describe(){
		throw new Error("我是蔬菜")
	}
}
```

Factory类

```js
class FoodsFactory {

	constructor(){
		this.food = new Object()
	}

	create(type) {
		if(type == 'meat') {
			this.food = new Meat()
		}else if(type == 'vegetables'){
			this.food = new Vegetables()
		}
		return this.food
	}
}
```

商店

```js
class Shop {
	constructor(foodsFactory){
		this.foodsFactory = foodsFactory
	}
	
	giveFood(type){
		const food = this.foodsFactory.create(type)
		food.describe()
	}
}
```

test：

```js
const foods = new FoodsFactory()
const shop = new Shop(foods)
shop.giveFood('meat')	// 输出：我是肉
shop.giveFood('vegetables')	// 输出：我是蔬菜
```

### 1.3 总结

简单工厂模式中工厂类的职责太重，一旦不能工作将影响整个系统，且如果添加过多的产品，工厂类中的逻辑就过于复杂。所以简单工厂模式适用于逻辑简单，且需要创建对象较少的情况。简单来说，在Factory中太多逻辑判断来生成对象，就会过于复杂，不容易维护啦！！

## 二、工厂方法模式

### 2.1 概述

上面的简单工厂模式，如果这时候增加一个新的食物“水果”，那么我们就要修改工厂类 FoodsFactory中的 create 函数。这是违反了设计模式中的开放封闭原则的，这样一直修改也是说明代码扩展能力不够。所以就有了工厂方法模式，来解决这些问题。

工厂方法模式与简单工厂不同地方在于，把工厂类抽象出一个父类。创建对象的事情交给其具体子类工厂完成。

### 2.2 运用

比简单工厂新增一个角色：

- ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。

FoodsFactory 抽象成父类，提供create函数，但是不参与具体逻辑

```js
class FoodsFactory {
	create(type) {
		throw new Error("此方法必须要重写")
	}
}
```

ConcreteFactory 类

```js
// 增加一个Meat的工厂
class MeatFactory extends FoodsFactory {
	create(){
		return new Meat()
	}
}

// 增加一个vegetables的工厂
class VegetablesFactory extends FoodsFactory {
	create(){
		return new Vegetables()
	}
}
```

修改 shop 类

```js
class Shop {
  constructor( foodsFactory ) {
     this.foodsFactory = foodsFactory ;
  }
  giveFood(){
    const food = this.foodsFactory.create();
    food.describe();
  }
}
```

test:

```js
const meatFactory = new MeatFactory()
const shop1 = new Shop(meatFactory)
shop1.giveFood()	// 输出： 我是肉

const vegetablesFactory = new VegetablesFactory()
const shop2 = new Shop(vegetablesFactory)
shop2.giveFood()	// 输出： 我是蔬菜
```











