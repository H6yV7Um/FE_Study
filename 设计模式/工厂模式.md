# 工厂模式 Factory

## 一、简单工厂模式

### 1.1 概述

简单工厂模式：简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一。它定义一个工厂类，它可以根据参数的不同返回不同的实例，被创建的实例通常都具有共同的父类。

简单工厂模式在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计。简单来说，就是我传一个参数（男、女、人妖）进去，可以创建对应性别的人出来。

### 1.2 运用

简单工厂模式的角色：

- Product（抽象产品类）：一般是一个抽象类或是接口
- ConcreteProduct（具体产品类）：实现或是继承 Product
- Factory（工厂类）：用来创建具体的产品

场景描述：我去商店买菜，结果老板跟我说，你要什么自己去拿吧(工厂类Factory)，那也就是，我想要什么这个动作，就是我们传参数进去来得到某个东西。

Product类

```js
// 抽象食物类
class Foods {
	describe(){
		throw new Error("此方法必须复写")
	}
}
```

ConcreteProduct类

```js
class Meat extends Foods {
	describe(){
		throw new Error("我是肉")
	}
}

class Vegetables extends Foods {
	describe(){
		throw new Error("我是蔬菜")
	}
}
```

Factory类

```js
class FoodsFactory {

	constructor(){
		this.food = new Object()
	}

	create(type) {
		if(type == 'meat') {
			this.food = new Meat()
		}else if(type == 'vegetables'){
			this.food = new Vegetables()
		}
		return this.food
	}
}
```

商店

```js
class Shop {
	constructor(foodsFactory){
		this.foodsFactory = foodsFactory
	}
	
	giveFood(type){
		const food = this.foodsFactory.create(type)
		food.describe()
	}
}
```

test：

```js
const foods = new FoodsFactory()
const shop = new Shop(foods)
shop.giveFood('meat')	// 输出：我是肉
shop.giveFood('vegetables')	// 输出：我是蔬菜
```

### 1.3 总结

简单工厂模式中工厂类的职责太重，一旦不能工作将影响整个系统，且如果添加过多的产品，工厂类中的逻辑就过于复杂。所以简单工厂模式适用于逻辑简单，且需要创建对象较少的情况。简单来说，在Factory中太多逻辑判断来生成对象，就会过于复杂，不容易维护啦！！

## 二、工厂方法模式

### 2.1 概述

上面的简单工厂模式，如果这时候增加一个新的食物“水果”，那么我们就要修改工厂类 FoodsFactory中的 create 函数。这是违反了设计模式中的开放封闭原则的，这样一直修改也是说明代码扩展能力不够。所以就有了工厂方法模式，来解决这些问题。

工厂方法模式与简单工厂不同地方在于，把工厂类抽象出一个父类。创建对象的事情交给其具体子类工厂完成。

### 2.2 运用

比简单工厂新增一个角色：

- ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。

FoodsFactory 抽象成父类，提供create函数，但是不参与具体逻辑

```js
class FoodsFactory {
	create(type) {
		throw new Error("此方法必须要重写")
	}
}
```

ConcreteFactory 类

```js
// 增加一个Meat的工厂
class MeatFactory extends FoodsFactory {
	create(){
		return new Meat()
	}
}

// 增加一个vegetables的工厂
class VegetablesFactory extends FoodsFactory {
	create(){
		return new Vegetables()
	}
}
```

修改 shop 类

```js
class Shop {
  constructor( foodsFactory ) {
     this.foodsFactory = foodsFactory ;
  }
  giveFood(){
    const food = this.foodsFactory.create();
    food.describe();
  }
}
```

test:

```js
const meatFactory = new MeatFactory()
const shop1 = new Shop(meatFactory)
shop1.giveFood()	// 输出： 我是肉

const vegetablesFactory = new VegetablesFactory()
const shop2 = new Shop(vegetablesFactory)
shop2.giveFood()	// 输出： 我是蔬菜
```

### 2.3 总结

工厂方法模式是对简单工厂模式的升级应用，它解决了简单工厂模式中工厂类职责繁重的问题，且更符合设计模式的开闭原则，增加新的产品不需要修改原先的代码，只需要增加对应的产品实例及工厂实例即可，同时这也是工厂方法模式的一个缺点，添加新产品，系统中的类就需要成对的增加，一定程度上增加了系统的复杂度。简单来说，添加一个新的产品就要创建一个对应的工厂类，这样的话，复杂程度会加大。

## 三、抽象工厂模式

### 3.1 概述

工厂方法模式通过引入产品工厂，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。这时候，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产。

抽象工厂模式定义是提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。

与简单工厂或工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。






